# Linux 网络高级 IO

## 五种IO模型

> 本文将介绍Linux网络编程中的五种常见网络高级IO函数
>
> 1. 阻塞IO
>    1. 在内核将数据准备好之前, 系统调用会一直等待. 
>    2. 所有的套接字, 默认都是阻塞方式.
> 2. 非阻塞IO
>    1. 如果内核还未将数据准备好, 系统调用仍然会直接返回
>    2. 返回EWOULDBLOCK错误码.
>    3. 该IO模式常需要以循环的方式反复尝试读写文件描述符, 这个过程称为`轮询`
>    4. 但是`轮询`会带来大量的CPU资源浪费，所以该IO模式一般只在特定场景下应用
> 3. 信号驱动IO
>    1. 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作
> 4. IO多路转接
>    1. 类似于阻塞IO,
>    2. 最核心在于IO多路转接能够同时等待多个文件 描述符的就绪状态
> 5. 异步IO
>    1. 在数据拷贝完成时, 内核会通知应用程序
>    2. 信号驱动则是告诉应用程序何时可以开始拷贝数据
>
> 总结：
>
> 所有的IO均可看作`等待` + `拷贝`，其中`等待`的时间常常远高于`拷贝`，所以高效的IO模式都是尽量减少等待的时间（后面会具体介绍）;

## 高级IO重要概念

### 同步通信 VS 异步通信



### 阻塞 VS 非阻塞



### 其他高级IO

非阻塞IO，纪录锁，系统V流机制，I/O多路转接（也叫I/O多路复用）,readv和writev函数以及存储映射 IO（mmap），这些统称为高级IO
本文重点讨论 I/O 多路转接；

## 非阻塞IO

### fcntl

文件描述符控制函数

**函数原型**

```c++
#include <iostream>
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* arg */);
```

**参数说明**

_cmd_

>F_DUPFD：										  复制一个现有的描述符
>
>F_GETFD / F_SETFD： 					  获得/设置文件描述符标记
>
>F_GETFL / F_SETFL： 					   获得/设置文件状态标记
>
>F_GETOWN / F_SETOWN：			   获得/设置异步I/O所有权
>
>F_GETLK / F_SETLK / F_SETLKW： 获得/设置记录锁







