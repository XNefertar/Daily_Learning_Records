# Linux 网络高级 IO

## 五种IO模型

> 本文将介绍Linux网络编程中的五种常见网络高级IO函数
>
> 1. 阻塞IO
>    1. 在内核将数据准备好之前, 系统调用会一直等待. 
>    2. 所有的套接字, 默认都是阻塞方式.
> 2. 非阻塞IO
>    1. 如果内核还未将数据准备好, 系统调用仍然会直接返回
>    2. 返回EWOULDBLOCK错误码.
>    3. 该IO模式常需要以循环的方式反复尝试读写文件描述符, 这个过程称为`轮询`
>    4. 但是`轮询`会带来大量的CPU资源浪费，所以该IO模式一般只在特定场景下应用
> 3. 信号驱动IO
>    1. 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作
> 4. IO多路转接
>    1. 类似于阻塞IO,
>    2. 最核心在于IO多路转接能够同时等待多个文件 描述符的就绪状态
> 5. 异步IO
>    1. 在数据拷贝完成时, 内核会通知应用程序
>    2. 信号驱动则是告诉应用程序何时可以开始拷贝数据
>
> 总结：
>
> 所有的IO均可看作`等待` + `拷贝`，其中`等待`的时间常常远高于`拷贝`，所以高效的IO模式都是尽量减少等待的时间（后面会具体介绍）;

## 高级IO重要概念

### 同步通信 (synchronous communication) VS 异步通信 (asynchronous communication)

同步和异步关注的是消息通信机制：

>- 同步
>
>直接由调用者进行等待，在处理完成之前，调用者会一直等待该处理结果的返回，期间调用者不会进行其他的操作；
>
>- 异步
>
>调用者不会一直进行阻塞式等待，当处理完成后，被调用者会通过一系列的机制（回调函数、信号等）通知调用者，调用者收到对应的完成信号后执行后续操作；

然而，需要注意与多进程/多线程同步/互斥的区别，两者毫不相关：

>- 进程/线程同步也是进程/线程之间直接的制约关系
>
>- 是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、 传递信息所产生的制约关系. 尤其是在访问临界资源的时候

### 阻塞 VS 非阻塞

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态

>- 阻塞调用是指调用结果返回之前，对应的线程会被挂起，直到收到响应信号时才会返回；
>- 非阻塞则不同于阻塞，即使未收到响应信号，线程也不会被挂起，而是继续执行接下来的操作；

### 其他高级IO

非阻塞IO，纪录锁，系统V流机制，I/O多路转接（也叫I/O多路复用）,readv和writev函数以及存储映射 IO（mmap），这些统称为高级IO
本文重点讨论 I/O 多路转接；

## 非阻塞IO

### fcntl

文件描述符控制函数，默认是阻塞 IO

**函数原型**

```c++
#include <iostream>
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* arg */);
```

**参数说明**

_cmd_

>F_DUPFD：										  复制一个现有的描述符
>
>F_GETFD / F_SETFD： 					  获得/设置文件描述符标记
>
>F_GETFL / F_SETFL： 					   获得/设置文件状态标记
>
>F_GETOWN / F_SETOWN：			   获得/设置异步I/O所有权
>
>F_GETLK / F_SETLK / F_SETLKW： 获得/设置记录锁

**用法实例**

——以设置文件描述符为非阻塞模式为例

```C++
void SetNoBlock(int fd){
    // 获取当前文件描述符模式
    int flag = fcntl(fd, F_GETFL);
    if(flag < 0){
        std::cerr << "ERROR FD" << std::endl;
        return;
    }
    // 设置文件描述符为非阻塞模式
    fcntl(fd, F_SETFL, flag | O_NONBLOCK);
}
```

_细节_

这里获取的`flag`，请注意它是一个位图结构，关于位图结构，可以粗略的将它看作是一个_比特位容器_，每个位置上的0/1值都代表着不同的含义，当然位图的实现依据不同的功能有不同的实现方案，肯定不会只是一个简单的`int`类型可表示的，这里只是用作理解；

**以轮询方式读取标准输入**

在我们完成了上述的非阻塞模式设置函数后，我们就可以基于此实现`以轮询方式读取标准输入`的功能：

```C++
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

void SetNoBlock(int fd){
    // 获取当前文件描述符模式
    int flag = fcntl(fd, F_GETFL);
    if(flag < 0){
        std::cerr << "ERROR FD" << std::endl;
        return;
    }
    // 设置文件描述符为非阻塞模式
    fcntl(fd, F_SETFL, flag | O_NONBLOCK);
}

int main()
{
    // 标准输入的文件描述符默认是0
    // 1 -> 标准输出
    // 2 -> 标准错误
    SetNoBlock(0);
    // 死循环模拟轮询状态
    for(;;)
    {
		char buffer[1024];
        // 读取
        // 以非阻塞方式
        ssize_t s = read(0, buffer, sizeof(buffer) - 1);
        if(s < 0){
            std::cerr << "ERROR READ" << std::endl;
            sleep(1);
            continue;
        }
        std::cout << "GetInput # " << buffer << std::endl; 
    }
    return 0;
}
```







