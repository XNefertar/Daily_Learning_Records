# 网络层协议——IP协议

——本文参考 游双 《Linux高性能服务器编程》

本篇文章要点：

- IPv4头部结构
- IP分片
- IP路由
- IP转发
- 重定向

## IPv4头部结构

IPv4通TCP报头类似，同样具有固定的报头长度（20字节）和可变的选项（最多40字节），其具体构成如图：

![屏幕截图 2024-10-25 001919](./PNG/png4.png)

- 4位版本号（version）：指定IP协议版本，目前主流的IP协议版本为IPv4，其值为4。对于其他的IP协议版本（IPv6等），有不同的值，其头部构造也与IPv4不同；
- 4位头部长度：用于标识IP报头的长度（不包括数据部分），因为有固定IP报头长度的存在，其取值范围为[20, 60]（字节）；
- 8位服务类型（Type of Service，TOS）：// TODO
- 16位总长度（Total Length）：指整个IP报文的长度，以字节为单位，所以IP数据报的理论长度为65535（2 ^ 16 - 1）字节。但是由于MTU（Maximum Transmission Unit）的限制，导致长度超过MTU限制的都将进行分片传输（关于分片，之后会重点介绍）；
- 16位标识（Identification）：用于唯一的标识主机发送的IP数据报文。其初始值有系统随机生成；每发送一个IP数据报，其值就递增1。该值在发生分片时会复制到每个分片中，因此每个分片具有相同的标识值，这是判断分片的重要标识之一；
- 3位标志：第一位保留（即暂时并未使用），第二位（Don't Fragment，DF）表示**禁止分片**，该标志位一旦设置，分片行为将被禁止，当IP数据报文长度大于MTU时，IP报文直接被丢弃；第三位（More Fragment，MF）表示**更多分片**，除了数据报的最后一个分片外，其他分片都需要将该标志设为1；
- 13位分片偏移（Fragment Offset）：分片相对原始IP数据报开始处（仅指数据部分）的偏移，在分片一节会重点介绍；
- 8位生存时间（Time to Live，TTL）：为了避免发生路由循环问题（会导致资源大量浪费，网络拥塞问题）而设置的路由器跳数限制，注意这里的生存时间并不是指的真实时间，而是路由器的跳数；
- 8位协议（Protocol）：用来区分上层协议，主要用于IP的分用过程；
- 16位头部校验和（Header Checksum）：与TCP类似，采用CRC算法检查IP头部；
- 32位源端和目的端IP地址：类似于TCP协议，只不过TCP是端口号，这里是IP地址，不予介绍；



## IP分片

主要介绍几个问题：

- 分片的细节问题；
- 分片的识别；
- 分片的组装（分片的次序问题）；
- 分片的缺点；

首先，我们要意识到：分片是一个迫不得已的策略，只是为了满足底层（数据链路层的Mac帧协议）的有限传输大小而采取的对策，其不会带来任何的传输效率上的优化，相反的，它会导致更多的丢包和数据传输问题；



_分片的细节_

这里举个例子来说明分片中的细节问题：比如我要传递一个2980字节的数据（其中已经包括了TCP头部等信息），假设我们不带任何选项，只有IP头部的固定20字节，此时我们一共需要传递3000字节的数据；

但是由于以太网的MTU只有1500字节，所以我们需要采取分片传输策略，我们先将1500字节的数据作为第一个分片，此时我们还剩下`3000 - 1500 = 1500`字节的数据需要传输；

这时有人会想，1500字节直接再作为一个分片传递，一共只需要两个报文即可完成数据的传递，但是这样吗？注意，每个分片都必须带有IP报头，因为**每个分片都是一个独立传输的报文**，理解了这个，就知道了上述的直接传递是不可取的；

所以我们要先添加IP报头20字节，再传递1480字节的有效数据，最后剩下的20字节再和20字节的IP报头组合，作为第三个分片进行传递；

![屏幕截图 2024-10-25 005722](./PNG/png5.png)

> 图中以1501字节为例



_分片的识别_

分片的识别前文已经提到一些，这里做一个总结：

> - 共用一个16位标识值的必然属于同一个分片
> - 3位标志位第三位为1 且 13位片偏移为0 的必然是分片组的第一个分片

