# Day2

今天我们谈谈HTTPS

## HTTPS

之前我们说过HTTP是不安全的，于是，大佬们提出了HTTPS，以解决HTTP不安全的问题，这个S，不是safe，是secure（没错，我一开始也猜错了）

所谓HTTPS，就是HTTP通过一种加密算法，对用户传输数据进行加密，从而避免被中间人窃取的一种安全通信协议，其中的加密算法，有SSL/TLS加密，保证其不被修改，窃听...我特意摘抄了部分ChatGPT的说法，以让这篇随笔显得更为专业：

>**HTTPS：超文本传输安全协议**
>
>**HTTPS**（HyperText Transfer Protocol Secure）是**HTTP协议**与**SSL/TLS加密**结合的一种安全通信协议，用于确保数据在客户端（如浏览器）与服务器之间的传输过程中不被窃听、篡改或伪造。相比HTTP，HTTPS提供了**身份认证、数据完整性**和**机密性**。

## 加密

好，介绍完本期的主题后，是不是意味着已经结束呢？

当然不是，我们先“请循其本”，回到用户最初的诉求——为什么我们需要加密呢？有人说这不是废话吗，不加密你不跟裸奔一个样吗。。。

确实，现在信息安全越来越受到人们的重视，在使用HTTP的年代，跟网上裸奔其实没有什么实质区别，就像我之前写的网络demo小组件一样，只要你是HTTP协议，甭管你是TCP，UDP还是其他啥协议，也不管你是GET方法，POST方法（话说POST方法会在用户输密码时将其隐藏，但总有种掩耳盗铃的感觉），使用我之前介绍的抓包工具（postman...），你传的所有信息，统统给你抓出来；

所以HTTPS协议应运而生，为什么要加密也变成一个设问句。。。下面我就来循序渐进的介绍一些加密方法：

### 对称加密

先说特点：一个密钥（这玩意读作"mi yue"，但我一般习惯读"mi yao"，想考普通话的同学注意了，这是个考点：）），速度快。

有同学就要问了，什么是密钥？你可以理解成一把钥匙，这把钥匙可以上锁和解锁，对应的就是加密和解密过程。

为什么有这两个特点呢？听我说完你就懂了：

假设我现在有一篇论文要传，几万字的那种，我怎么传？直接传吗？（专业点说应该是明文传输）——那我说这么多白说了，不加密等于裸奔！

那有人就要问了，怎么加密呢？——对称加密规定：加密和解密使用__相同的密钥__，客户端和服务端使用该密钥进行加密和解密操作；

说人话就是，你和服务器端（比如腾讯啦，B站啦等等）__共用一把钥匙__（这也是它为什么叫做对称加密的原因），然后你想把数据传到服务器，你就把数据写在纸上，放到一个箱子里（可以是任何东西，这里只是做个比喻），用你的钥匙上锁，他那边收到箱子后，就用一把相同的钥匙打开锁，读取里面的数据；

他要是想给你发数据呢，也是一样的；

这就是特点里说的一把密钥，至于速度为什么快呢，因为这里全程只有一把密钥参与，这么说可能没有说服力，等接下来介绍其他的加密方法时，你就理解为什么说他快了。

这时，有聪明的同学就要问了——为什么它们可以有一样的钥匙呢？好问题，因为这个东西是无解的，因为你如果想只通过单纯的对称加密算法实现加密功能的话，抱歉，此题无解，按照专业的说法，这个问题叫做：

> 单纯使用**对称加密**在**数据传递**中会面临**密钥交换和管理**等安全问题

形象点来说就是你没办法保证服务端和客户端具有相同的密钥！！！

有同学可能会问，通过网络传过去不就行了？请问怎么传，明文传还是密文传？

明文传？万一黑客中途给你一截断，反正是明文，黑客也能看得懂，也能用起来，你开开心心的拿着密钥，想着发一些隐私数据给你的服务端，还幻想着自己有着密钥，黑客早就用你传的密钥拿到了你的信息，然后明码标价的出现在一些黑商手里，而你还在沾沾自喜(：）)

那密文传呢？你一加密，请问没有对应钥匙的服务端怎么知道你传了什么，这个世界上除了你就没人能获取你的信息了(：( )

介绍完了这些，下面我们来简要说说它的加密原理，还是那篇论文，我先对它对散列算法（英文是hash function，所以为了方便理解，我一般叫它hash算法）处理，常见的有MD5算法，SHA-256（这个的安全性更高，被广为使用），随后会形成一个固定长度的字符串，一般称之为数据摘要（也叫数据指纹），而密钥就是对数据摘要做处理，形成数据签名，可以思考一下，hash算法可逆吗（不可逆，你能根据哈希表推出来原始字符长啥样吗？），加密解密呢（肯定可逆，这个不可逆密码学就不复存在了：）），这就是加密解密的一般过程（只是简化模型，为了便于理解，实际的加密解密过程极为复杂，想要详细了解可以看看密码学对应的书籍）

所以说，单纯的依赖对称加密是行不通的，你永远无法实现安全的信息传递！！！

那怎么办？别着急，我们继续往下看：



### 非对称加密

顾名思义，这种加密方式应该是存在不止一个密钥的（确实，你猜对了），下面我就来介绍一下这种加密方式：

这种加密方式需要服务端形成一对密钥，分别叫做**公钥**（**Public**，就是大家都能看见的）和**私钥**（**Private**，就是只有服务端能看见的）。有了这两个东西，就可以实现安全通信了吗？....

首先，服务端将公钥传到客户端，以后客户端想要发消息时，先通过公钥加密，然后传到服务端。服务端通过自己的私钥完成解密，获取对应信息。这个过程中即使黑客拿到了公钥，但是他没有服务端的私钥，就无法打开被公钥锁住的信息，于是信息被安全传递？（不是打错符号了，这是伏笔：））

那我服务端想传信息呢？聪明的你肯定想到了客户端再维持一个公私钥匙对不就行了？虽然可行，但你不觉得花销太大了吗（还记得我之前说的为什么对称加密快了吧，你看看这里的钥匙有多少把，就知道它有多耗时了！！）

你是不是觉得开销这么大，肯定是安全的吧（哈哈，还记得我上面的伏笔吗，这种通过单纯的非对称加密，也是无法实现数据的安全传输的！！！）是不是有种白努力的无力感：），那有人要问了，为什么啊？

你仔细想想，虽然你传公钥不怕被黑客知道，但是如果我把公钥整个替换了会怎么样呢？？？

比如说，你作为客户端，向服务端传了一个公钥 C，这时候我作为一个黑客，看到了你传的公钥，我给你来个偷梁换柱，把你的公钥换成我的公钥，比如说 H，发送给服务端。然后把你保存的公钥再发回给客户端。

随后服务端接收到了公钥，利用公钥对数据进行加密，向客户端传送，又被我这个黑客截获。因为你使用的是我的公钥，所以我可以用我的私钥解开，获取里面的信息。然后再用我保存下来的你的公钥加密，最后发送给你。

这时候的你收到消息，你看到的是一个带着你的公钥的信息，你会质疑它被其他人动过吗——不，你不会；然后你就开开心心的解密，读取服务端给你的信息，窃喜终于可以进行安全的信息传递了，谁知你的信息又一次的明码标价被挂在了黑商手上。。。

------

这么说难道没有方法限制黑客盗取我的信息了吗？....



### 对称加密 + 非对称加密

既然两者都有缺陷，那我把他们结合一下，各取其长，是不是就可以了呢？

我们可以在第一次通信时先将服务端生成的公钥传过去，客户端接收到后，使用公钥将客户端生成的对称密钥加密后传送过去，之后的所有通信行为就可以使用对称加密的密钥进行加密和解密了，但是这样就安全了吗？

但是，你仔细想想，这个好像还是解决不了数据安全传输的问题，还是会出现第一次传输时发生的公钥整体替换的事故；但是！！，这样的加密方式可以极大的优化加密和解密速度，从而提高两者之间的通信效率；

那有人就要问了，还有其他办法吗？



### 对称加密 + 非对称加密 + 证书

其实，我们发现，只要保证第一次可以将服务端生成的公钥安全的传给客户端，之后的通信就可以认为是安全的，那么有什么方法呢？

#### CA证书

看到这个标题，有同学就要问了，证书是什么？注意，这里的证书可不是你的获奖证书啥的，这是由一个专业权威的机构颁发的数字证书，用于验证和确认一个公钥的真实性，专业解释为：

> CA 证书是指 **证书授权中心（Certificate Authority，CA）** 颁发的数字证书，用于验证和确认一个公钥的真实性。它在网络安全和通信中扮演着重要的角色，尤其是在 **SSL/TLS** 协议中，用于保护数据传输的安全性。

> 它主要包含一下信息：
>
> **证书持有者的信息**：
>
> - **姓名**、**组织**、**域名**等。
>
> **公钥**：
>
> - 用于加密和数字签名的公钥。
>
> **证书颁发者信息**：
>
> - CA 的名称、序列号等信息。
>
> **有效期**：
>
> - 证书的起始和结束日期。
>
> **签名**：
>
> - CA 使用其私钥对证书进行签名，以保证证书的完整性和真实性。

**CA证书**是它的全称，这个证书由**服务端**请求获取。服务端会向该机构发送自己的**公钥**、**申请者**、**域名**等信息。CA机构在审核完成后，首先会先使用hash算法，对服务端信息进行处理，形成数据摘要，随后使用**CA内部的私钥**对数据进行加密处理，注意，这个私钥是**CA机构独有的**，所有人都无法得知。正因为这个原因，只有通过CA机构颁发的证书才具有**合法性**（当然，现在世界各地也有很多**下属机构**执行CA机构的职责，毕竟想通过一个机构实现全球的证书管理工作，几乎是不可能的）；

在私钥加密完成后，会形成一个对应的**数据签名**（因为是对数据摘要进行加密处理的，所以所有的数据签名的字节数都是相同的），最后，会**连同服务端的信息和数据签名**，一起打包形成大名鼎鼎的**CA证书**，颁发给服务端；

#### 如何保证数据的正确传输

有了**CA证书**，数据最终就可以完成安全的传输工作了：

首先，**服务端**会想着将自己的**公钥**传过去，这次它学聪明了，不是在傻傻的直接传了。记得上面说的吗，证书的申请信息会要求服务端提供其公钥信息，所以这次只用将**CA证书**整个传过去就可以了。

这时候的**黑客**看到服务端又传来了信息，准备再来个偷天换日，发现这个公钥和以往的不一样，似乎多了一点东西……

但是黑客不管，依旧将公钥（这里服务端的用 **S** 标识）换成自己的公钥（用 **H** 表示），并将原来的 **S** 保存下来，然后再发给 **客户端**。

客户端接收到“服务端”（这里是黑客）发过来的消息后，不是立刻使用公钥进行加密操作，它会先**验证证书的合法性**！！！

首先将**数据签名**和其他信息分离，然后使用**CA证书的公钥**（公钥是已知的）对数字签名进行解密，形成一个**hash数据**。接着，使用**hash算法**对其他信息进行处理，同样生成一个 hash 数据，最后比较二者是否相同。一旦发现二者不同，说明传入的数据被其他人篡改过，随机该数据被丢弃，从而实现公钥的安全递达。

公钥递达完成后，服务端和客户端终于可以开始愉快的通信了，不再受到其他中间人的监听。

由此，便可以通过 **CA证书** 最终实现服务端和客户端间的安全通信！！！

同学们之前可能会遇到访问一个网站时提示说该网站的**安全证书已过期**，这就是上述说明的**CA证书**（不一定是CA证书，因为其下属有很多机构，但其作用原理是一样的）。同样注意，CA证书也是有期限的，一旦超过该期限，安全证书同样会失效。